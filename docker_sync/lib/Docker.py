# -*- encoding: utf-8 -*-

import logging
import time
import subprocess
import types

# http://docs.python-requests.org/en/v1.2.3/
import requests

from ImageTag import ImageTag
from Image import Image
from Container import Container

class Docker(object):
    """interfaces with the local Docker daemon"""
    
    API_VERSION = "1.8"
    
    def __init__(self, http_port):
        super(Docker, self).__init__()
        
        self.logger = logging.getLogger("Docker")
        self.logger.setLevel(logging.DEBUG)
        
        self.base_url = "http://127.0.0.1:%d/v%s" % (http_port, Docker.API_VERSION)

        self.images = {}
        self.containers = {}

    def __get(self, path):
        retVal = None
        url = self.base_url + path

        self.logger.debug(url)

        start = time.time()
        resp = requests.get(url)
        duration = time.time() - start

        self.logger.debug("%s %d %.2f", url, resp.status_code, duration)
        
        if resp.status_code == requests.codes.ok:
            retVal = resp.json()
        elif resp.status_code != requests.codes.not_found:
            resp.raise_for_status()

        return retVal
    
    def getImages(self):
        """ returns a dict of image_tag => Image instance """
        
        self.images = {}
        
        for img in self.__get("/images/json?all=1"):
            tags = [ ImageTag.parse(t) for t in img["RepoTags"] ]

            image = Image(img["Id"])
            image.tags = tags
            
            for t in image.tags:
                if t:
                    self.images[t] = image
            
        return self.images
    
    def getImage(self, name):
        """ returns an Image for the given name, or None if not found """
        
        retVal = None
        
        img_data = self.__get("/images/%s/json" % name)
        
        if img_data:
            retVal = Image(img_data["id"])
            retVal.tags = [ name if isinstance(name, ImageTag) else ImageTag.parse(name) ]
        
        return retVal
    
    def getContainers(self):
        """ returns a dict of container name => Container """

        ## find all containers
        self.containers = {}
        
        for cont in self.__get("/containers/json?all=1"):
            ## get names without leading "/"
            names = [ n[1:] for n in cont["Names"] ]
            
            ## canonical name has no slashes
            canonical_name = [ n for n in names if "/" not in n ][0]
            
            cont_detail = self.__get("/containers/%s/json" % canonical_name)
            
            container = Container(canonical_name, cont_detail["ID"], Image(cont_detail["Image"]))
            
            container.hostname = cont_detail["Config"]["Hostname"]
            container.running = cont_detail["State"]["Running"]
            
            env_str = cont_detail["Config"]["Env"]
            if env_str:
                container.env = dict([ e.split("=", 1) for e in env_str])
                
                ## remove stuff generated by Docker
                for key in ("PATH", "HOME"):
                    if key in container.env:
                        del container.env[key]
                
                if not container.env:
                    container.env = None
            
            if cont_detail["HostConfig"]["PortBindings"]:
                for port_def in cont_detail["HostConfig"]["PortBindings"]:
                    binding = cont_detail["HostConfig"]["PortBindings"][port_def]
                    
                    ## binding is none if port not mapped to host
                    if binding:
                        if container.ports is None:
                            container.ports = {}
                        
                        ## @todo uh, why is this a list?
                        binding = binding[0]

                        ## HostPort is a number in yaml but string in binding
                        container.ports[port_def] = {
                            "HostIp": binding["HostIp"],
                            "HostPort": int(binding["HostPort"]),
                        }
            
            ## { "/container/mount": { "HostPath": "/some/path", "ReadWrite": True}}
            if cont_detail["HostConfig"]["Binds"]:
                container.volumes = {}
                
                ## [ "/host/path:/container/path:ro" ] :ro is optional
                for bind_info in cont_detail["HostConfig"]["Binds"]:
                    read_write = True
                    if bind_info.endswith(":ro"):
                        read_write = False
                        bind_info = bind_info[:-3]
                    
                    host_path, container_path = bind_info.split(":", 1)
                    
                    container.volumes[container_path] = {
                        "HostPath": host_path,
                        "ReadWrite": read_write,
                    }
            
            container.command.append(cont_detail["Path"])
            container.command.extend(cont_detail["Args"])
            
            self.containers[container.name] = container
            # pprint(("Container", container.__dict__))
        
        return self.containers
    
    def removeContainer(self, name):
        self.logger.info("stopping %s", name)
        
        subprocess.check_call([ "docker", "stop", name ])
        
        ## rm -v to remove volumes; we should always explicitly map a volume to
        ## the host, so this should be a non-issue.
        self.logger.info("removing %s", name)
        
        subprocess.check_call([ "docker", "rm", "-v", name ])
    
    def startContainer(self, container):
        # docker run -d -v … -e … -p … $image $cmd
        cmd = [ "docker", "run", "-d", "-name", container.name ]
        
        if container.hostname:
            cmd.extend([ "-h", container.hostname ])
        
        if container.volumes is not None:
            for vol_name in container.volumes:
                vol_def = container.volumes[vol_name]
                
                cmd.extend([
                    "-v",
                    "%s:%s%s" % (vol_def["HostPath"], vol_name, "" if vol_def["ReadWrite"] else ":ro"),
                ])
        
        if container.env is not None:
            for key in container.env:
                cmd.extend([ "-e", "%s=%s" % (key, container.env[key] )])

        if container.ports is not None:
            for port_spec in container.ports:
                port_def = container.ports[port_spec]
                
                cmd.extend([
                    "-p",
                    "%s:%s:%s" % (port_def["HostIp"], port_def["HostPort"], port_spec)
                ])
        
        cmd.append(str(container.image_tag))
        
        if container.command:
            cmd.extend(container.command)
        
        subprocess.check_call(cmd)
    
    def getImageIdFromRegistry(self, image_tag):
        ## http://localhost:5000/v1/repositories/apps/mongodb/tags/latest
        ## actually returns a list of every layer with that tag.  assuming you'd
        ## grab the first, but that seems weird.
        
        regUrl = "http://%s/v1/repositories/%s/tags" % (
            image_tag.registry if image_tag.registry else "index.docker.io",
            image_tag.repository,
        )
        
        attempts = 0
        success = False
        while not success and attempts < 3:
            attempts += 1
            
            self.logger.debug(regUrl)
            
            try:
                start = time.time()
                resp = requests.get(regUrl)
                duration = time.time() - start
                
                self.logger.debug("%s %d %.2f", regUrl, resp.status_code, duration)
                
                success = True
            except requests.exceptions.ConnectionError, e:
                self.logger.warn("connection error; sleeping 5", exc_info=True)

                time.sleep(5)
        
        if not success:
            self.logger.error("giving up")
            raise e
        
        ## if public registry (index.docker.io):
        ##      [ {"name":"tag", "layer": "<id>"}, …]
        ## else
        ##      { "tag": "<id>", … }
        ## I'm probably looking in the wrong place, but I don't think I can
        ## query the registry without authenticating to the index, and that's
        ## just a pain in the ass.
        layers = resp.json()
        
        if type(layers) == types.ListType:
            layers = dict(map(lambda x: (x["name"], x["layer"]), layers))

        return layers[image_tag.tag]


    def pullImage(self, image_tag):
        # @todo don't need to pull all the images; use self.getImage()
        local_images = self.getImages()
        
        registry_img_id = self.getImageIdFromRegistry(image_tag)
        must_pull = True
        
        if image_tag in local_images and local_images[image_tag].id == registry_img_id:
            self.logger.info("%s is up to date", image_tag)
            
            must_pull = False
        
        if must_pull:
            self.logger.info("pulling %s", image_tag)
            
            subprocess.check_call([ "docker", "pull", str(image_tag) ])
        
        return self.getImage(image_tag)
